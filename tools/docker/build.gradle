/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our samples at https://docs.gradle.org/7.6.4/samples
 */
import java.text.SimpleDateFormat

//allprojects {
//    version = "1.0.0"
//    apply plugin: "java-library"
//}

version = "1.0.0"
apply plugin: "java-library"

def getGitCommitDetails(length = 8) {
    try {
        def gitFolder = "${rootDir}/../.git/"
        if (!file(gitFolder).isDirectory()) {
            gitFolder = file(gitFolder).text.substring(length).trim() + "/"
        }
        def takeFromHash = length
        def head = new File(gitFolder + "HEAD").text.split(":")
        def isCommit = head.length == 1

        def commitHash, refHeadFile
        if (isCommit) {
            commitHash = head[0].trim().take(takeFromHash)
            refHeadFile = new File(gitFolder + "HEAD")
        } else {
            refHeadFile = new File(gitFolder + head[1].trim())
            commitHash = refHeadFile.text.trim().take(takeFromHash)
        }

        // Use head file modification time as a proxy for the build date
        def lastModified = new Date(refHeadFile.lastModified())
        // Format the date as "yy.M" (e.g. 24.3 for March 2024)
        def formattedDate = new SimpleDateFormat("yy.M").format(lastModified)

        return [hash: commitHash, date: formattedDate]
    } catch (Exception e) {
        logger.warn('Could not calculate git commit details, using defaults (run with --info for stacktrace)')
        logger.info('Error retrieving git commit details', e)
        return [hash: "xxxxxxxx", date: "00.0"]
    }
}

// http://label-schema.org/rc1/
// using the RFC3339 format "2016-04-12T23:20:50.52Z"
def buildTime() {
    def df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'")
    df.setTimeZone(TimeZone.getTimeZone("UTC"))
    return df.format(new Date())
}

// set the shell command to use according to os
def shell = org.gradle.internal.os.OperatingSystem.current().isWindows() ? "${projectDir}\\wslsh.bat" : '/bin/bash'

def dockerBuildVersion = project.hasProperty('release.releaseVersion') ? project.getProperty('release.releaseVersion') : "latest"
def dockerOrgName = project.hasProperty('dockerOrgName') ? project.getProperty("dockerOrgName") : "tronprotocol"
def dockerArtifactName = project.hasProperty("dockerArtifactName") ? project.getProperty("dockerArtifactName") : "java-tron"
def dockerImageName = "${dockerOrgName}/${dockerArtifactName}"

task sourceDocker {
    def dockerBuildDir = "${rootDir}/build/docker-tron/"

    doLast {
        copy {
            from file("${rootDir}/../docker/Dockerfile")
            into(dockerBuildDir)
        }
        copy {
            from file("${rootDir}/../docker/docker-entrypoint.sh")
            into "${dockerBuildDir}"
        }
        exec {
            def image = "${dockerImageName}:${dockerBuildVersion}"
            def dockerPlatform = ""
            if (project.hasProperty('docker-platform')){
                dockerPlatform = "--platform ${project.getProperty('docker-platform')}"
                println "Building for platform ${project.getProperty('docker-platform')}"
            } else {
                dockerPlatform = "--platform linux/amd64"
                println "Building for default linux/amd64 platform"
            }
            def gitDetails = getGitCommitDetails(7)
            executable shell
            workingDir dockerBuildDir
            args "-c", "docker build ${dockerPlatform} --build-arg BUILD_DATE=${buildTime()} --build-arg VERSION=${dockerBuildVersion} --build-arg VCS_REF=${gitDetails.hash} -t ${image} ."
        }
    }
}


task testDocker {
    dependsOn sourceDocker
    def dockerReportsDir = "${rootDir}/../docker/reports/"

    doFirst {
        new File(dockerReportsDir).mkdir()
    }

    doLast {
        exec {
            def image = "${dockerImageName}:${dockerBuildVersion}"
            workingDir "${rootDir}/../docker"
            executable shell
            args "-c", "./test.sh ${image}"
        }
    }
}

// Make sure to `docker login` first
task dockerUpload {
    dependsOn sourceDocker
    def image = "${dockerImageName}:${dockerBuildVersion}"

    doLast {
        exec {
            def cmd = "docker push '${image}'"
            println "Executing '${cmd}'"
            executable shell
            args "-c", cmd
        }
    }
}

tasks.named('jar') {
    enabled = false
}
